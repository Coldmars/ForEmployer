# Participant Viewer
## Суть приложения
Заявки на участие в мероприятии независимо собирали несколько информационных сервисов. Каждый сервис экспортировал данные в свой формат. Файлы сервисов с данными:
<br> ● Сервис №1 - participants.json
<br> ● Сервис №2 - participants.xml
<br> ● Сервис №3 - participants.csv

Требования:
<p> 1. Пользователь приложения должен иметь возможность:
<br> a. Постранично просматривать участников мероприятия. Размер страницы - 5 элементов.
<br> b. Искать участников по части фамилии или имени.
<p> 2. Любой результат выборки должен быть отсортирован по дате регистрации.
<p> 3. Для отображения любых результатов данные необходимо объединить из всех вышеупомянутых источников.
<p> 4. Если один и тот же участник зарегистрировался несколько раз (имеется более чем в одном файле), то:
<br> a. Он не должен повторяться в списке.
<br> b. Из дубликатов должна быть выбрана запись с наиболее ранней датой регистрации.
<br> c. Дублированной считается запись, если фамилия и имя совпадает.
<p> 5. В разных источниках даты представлены в разных форматах. Необходимо привести к единому ("20.10.2019 10:15").
<p> 6. Приложение должно быть реализовано в виде консольного приложения.
<p> 7. Список команд:
<br> "get-page 3" - Получение указанной страницы списка
<br> "search "Ива" - Поиск по списку

## Архитектура
Приложение было спроектировано с помощью паттерна "Стратегия". Это паттерн позволяет нам переключаться между схожими алгоритмами прямо во время исполнения программы. 

### Модуль чтения данных с файлов
Например, рассмотрим модуль приложения, отвечающий за чтение данных с файлов. У нас три разных алгоритма (обработка json, xml, csv). Каждый алгороитм - это отдельный класс, который реализует интерфейс IFormatter.
Также, у нас есть класс Importer, который устанавливает конкретный алгоритм и запускает его. Класс Importer хранит в себе ссылку на экземпляр класса, реалзиующего интерфейс IFormatter.
Засчёт этого достигается гибкость: мы передает объекту Importer объект IFormatter. Также, достигается расширяемость: если нам нужен будет новый алгоритм обработки данных, мы без труда 
сможем добавить его, просто реализовав интерфейс IFormatter. 

Данные с файлов десериализуются в объекты Participant и заносятся в общий репозиторий ParticipantsRepository.

### Модуль команд
Модуль команд был реализован по схожему принципу. Каждая команда (Get-page, Search) представляет с собой отдельный класс, реализующий интерфейс ICommand. Этот интерфейс заставляет классы
команд реализовать метод Execute (выполнение команды). Объекты команд хранят в себе репозиторий объектов, над которыми необходимо провести операцию и аргумент. 

Сами команды хранятся в словаре Dictionary<string, Func<IParticipantsRepository, String, ICommand>>, где ключ - название команды, а значение - создание объекта команды.

Вызов команды происходит с помощью обработчика команд CommandHandler. Обработчику передается два аргумента - репозиторий команд и репозиторий участников. Ключевым является метод 
Run, которому передается строка с командой и агрументом (например "get-page 1"). Это строка парсится, отдельно выделяются название команды, отдельно - аргумент, 
и сохраняются в закрытый полях. Затем производится распознавание команды по ее названию в словаре и в случае успеха вызывается значение найденного ключа - то есть вызывается 
объект конкретной команды. Этот объект также запоминается в закрытом поле, и вызывается его метод - Execute.

Интерфейсы репозиториев ICommandRepository и IParticipantsRepository обеспечивают гибкость - нет жесткой привязки к конкретным объектам, что позволяет легко проводить тестирование.

Данный подход позволяет сделать наш код расширяемым и гибким. Мы в любой момент можем создавать новые команды, и ничего изменять не надо.
Минус: сложная система классов.

## Производительность
Был задействован пул потоков исполнения. Методы импортирования данных с файлов в репозиторий объектов производятся не одним потоком, что значительно ускоряет выполнение.
Пул потоков самостоятельно управляет потоками, самостоятельно выделяет нужное количество потоков исполнения. 

Более того, применяется асинхронное программирование. Эти методы импортирования запускаются в начале, а ожидаются уже после того, как пользователь ввел команду в консоль.
То есть импорт данных запускается с запуском самой программы, и время, пока пользователь вводит команду, также используется этими методами.

В итоге, скорость иипорта данных уменьшилась с 500-600 мс до 2-5 (!) мс. И да, я не поленился это проверить :) 
